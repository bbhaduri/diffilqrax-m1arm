

def linesearch(
    update: Callable,
    Ks: lqr.Gains,
    Xs_init: Array,
    Us_init: Array,
    cost_init: float,
    alpha_0: float,
    expected_dJ: lqr.CostToGo,
    beta: float,
    max_iter: int = 20,
    tol: float = 0.99999,
    alpha_min=0.0001,
    verbose: bool = False,
):
    
    # initialise carry: Xs, Us, old ilqr cost, alpha, n_iter, carry_on
    initial_carry = (Xs_init, Us_init, 0., cost_init, alpha_0, 0, 10., 0., True)
    jax.debug.print(f"Initial LQR cost: {cost_init:.03f} with alpha: {alpha_0:.03f}")
    def backtrack_iter(carry):
        """Rollout with new alpha and update alpha if z-value is above threshold"""
        # parse out carry
        Xs, Us, new_cost, old_cost, alpha, n_iter, _, _, carry_on = carry
        # rollout with alpha
        (new_Xs, new_Us), new_cost = update(Ks, Xs, Us, alpha=alpha)

        # calc expected cost reduction
        expected_delta_j = lqr.calc_expected_change(expected_dJ, alpha=alpha)
        # calc z-value
        z = (old_cost - new_cost) / expected_delta_j
        
        if verbose:
            jax.debug.print(f"it:{n_iter:02} exp: {expected_dJ.V:.03f}, {expected_dJ.v:.03f} a:{alpha:.03f} z:{z:.03f} oJ:{cost_init:.03f} pJ:{old_cost:.03f} nJ:{new_cost:.03f} DJ:{old_cost-new_cost:.03f} exp_DJ:{expected_delta_j:.03f}")

        # ensure to keep Xs and Us that reduce z-value
        new_cost = jnp.where(jnp.isnan(new_cost), cost_init, new_cost)
        # add control flow to carry on or not
        above_threshold = z > tol
        carry_on = lax.bitwise_not(jnp.logical_and(alpha > alpha_min, above_threshold))
        # Only return new trajs if leads to a strict cost decrease
        new_Xs = jnp.where(above_threshold, new_Xs, Xs)
        new_Us = jnp.where(above_threshold, new_Us, Us)
        new_cost = jnp.where(above_threshold, new_cost, old_cost)
        # update alpha
        alpha *= beta
        # alpha -= 0.01

        return (new_Xs, new_Us, new_cost, old_cost, alpha, n_iter + 1, z, expected_delta_j, carry_on)

    def loop_fun(carry_tuple: Tuple[Array, Array, float, float, int, bool], _):
        """if cond false return existing carry else run another rollout with new alpha"""
        # assign function given carry_on condition
        updated_carry = lax.cond(
            carry_tuple[-1], backtrack_iter, lambda x: x, carry_tuple
        )
        return updated_carry, (updated_carry[2], updated_carry[3])

    # scan through with max iterations
    (Xs_opt, Us_opt, cost_opt, old_cost, alpha, its, z, exp_dj, *_), costs = lax.scan(
        loop_fun, initial_carry, None, length=max_iter
    )
    
    if verbose:
        jax.debug.print(f"{its-1} ls_iters:\t alpha={alpha/beta:.03f}\t Jold={cost_init:.03f}\t J={cost_opt:.03f}\t DJold={cost_init-cost_opt:.03f}\t exp_DJ={exp_dj:.03f}\t z={z:.03f}\t alpha_0={alpha_0:.03f}")
        jax.debug.print(f"New LQR passed: {cost_opt:.03f} with alpha: {alpha/beta:.03f} in {its} iterations")
    return (Xs_opt, Us_opt), alpha, cost_opt, costs

